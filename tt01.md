---
header-includes:
- \hypersetup{colorlinks=false,
          allbordercolors={0 0 0},
          pdfborderstyle={/S/U/W 1}}
---
# M segments



* Author Matt Venn
* Description Setting the correct input will show a 3 on the display
* [GitHub project](https://github.com/mattvenn/tinytapeout_m_segments)
* [Wokwi project](https://wokwi.com/projects/339688086163161683)
* [Extra docs](https://github.com/mattvenn/tinytapeout_m_segments/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

AND gates connect to the 7 segment display

## How to test

Turning on the first 4 inputs will show a 3 on the display

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input 1  | segment a |
| 1 | input 2  | segment b |
| 2 | input 3  | segment c |
| 3 | input 4  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | none  | segment g |
| 7 | none  | dot |

\pagebreak
# Barrelshifter



* Author Johannes Hoff
* Description Shifts a 6 bit number up to 0-3 bits left
* [GitHub project](https://github.com/johshoff/barrelshifter-wokwi-gds)
* [Wokwi project](https://wokwi.com/projects/341136771628663380)
* [Extra docs]()
* Clock 0 Hz
* External hardware 

## How it works

An 6 bit input value and 2 bit shift amount is provided, and the shifted value will be in the output

## How to test

Choose an input value (like 6'b001010) and a shift amount (like 2'b10) and combine it into input pins (like 8'b00101010) and observe that the output is the shifted input (like 8'b10100000)

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | bit 5 (most significant) of input value  | bit 7 (most significant) of shifted value |
| 1 | bit 4 of input value  | bit 6 of shifted value |
| 2 | bit 3 of input value  | bit 5 of shifted value |
| 3 | bit 2 of input value  | bit 4 of shifted value |
| 4 | bit 1 of input value  | bit 3 of shifted value |
| 5 | bit 0 (least significant) of input value  | bit 2 of shifted value |
| 6 | bit 5 (most significant) of shift amount  | bit 1 of shifted value |
| 7 | bit 0 (least significant) of shift amount  | bit 0 (least significant) of shifted value |

\pagebreak
# PDM driver



* Author Harry Snell
* Description 5-bit pulse density modulation encoder (aka sigma-delta converter)
* [GitHub project](https://github.com/H-S-S-11/tinytapeout-verilog-test)
* [Wokwi project](https://wokwi.com/projects/341154068332282450)
* [Extra docs](https://github.com/H-S-S-11/tinytapeout-verilog-test/blob/main/README.md)
* Clock 200 Hz
* External hardware Clock source, switches for input. LED, RC circuit, logic analyser or oscilloscope to view output

## How it works

The pdm_input is registered when write_en is high. The registered input is added to an accummulator on each cycle. The overflow bit of the sum is pdm_output.

## How to test

Set reset low and write_en high, provide a clock (frequency not important) and put a 5-bit number on pdm_input and see how the average value on pdm_out changes

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | pdm_out |
| 1 | reset  | pdm_out_n |
| 2 | write_en  | none |
| 3 | pdm_input[0]  | none |
| 4 | pdm_input[1]  | none |
| 5 | pdm_input[2]  | none |
| 6 | pdm_input[3]  | none |
| 7 | pdm_input[4]  | none |

\pagebreak
# BCD to Decimal Decoder



* Author JinGen Lim
* Description Converts a BCD input into a decimal output
* [GitHub project](https://github.com/jglim/tinytapeout_bcd-dec)
* [Wokwi project](https://wokwi.com/projects/341161378978988626)
* [Extra docs](https://github.com/jglim/tinytapeout_bcd-dec/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

Accepts BCD through 4 input pins, and outputs the decimal equivalent (output pins 0 to 7). This is a functional clone of the DM7447, but does not include values 8 and 9 due to package constraints.

## How to test

Write to the BCD input (IN0:0, IN1:2, IN2:4, IN3:8). One corresponding decimal output pin will be driven high.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input 1 (BCD 1)  | decimal output 0 |
| 1 | input 2 (BCD 2)  | decimal output 1 |
| 2 | input 3 (BCD 4)  | decimal output 2 |
| 3 | input 4 (BCD 8)  | decimal output 3 |
| 4 | none  | decimal output 4 |
| 5 | none  | decimal output 5 |
| 6 | none  | decimal output 6 |
| 7 | none  | decimal output 7 |

\pagebreak
# BCD to 7-Segment Decoder



* Author JinGen Lim
* Description Converts a BCD input into a 7-segment display output
* [GitHub project](https://github.com/jglim/tinytapeout_bcd-7seg)
* [Wokwi project](https://wokwi.com/projects/341152580068442706)
* [Extra docs](https://github.com/jglim/tinytapeout_bcd-7seg/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

The IC accepts four binary-coded decimal input signals, and generates a corresponding 7-segment output signal

## How to test

Connect the segment outputs to a 7-segment display. Configure the input (IN0:0, IN1:2, IN2:4, IN3:8). The input value will be shown on the 7-segment display

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input 1 (BCD 1)  | segment a |
| 1 | input 2 (BCD 2)  | segment b |
| 2 | input 3 (BCD 4)  | segment c |
| 3 | input 4 (BCD 8)  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | none  | segment g |
| 7 | none  | none |

\pagebreak
# Barrel Shifter



* Author Shahzaib Kashif
* Description shifts the data n times, where n is the input provided via inputs
* [GitHub project](https://github.com/shahzaibk23/tinytapeout-barrel-shifter)
* [Wokwi project](https://wokwi.com/projects/341167691532337747)
* [Extra docs](https://github.com/shahzaibk23/tinytapeout-barrel-shifter/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

muxes connect to output

## How to test

give input through input ports and toggle select pins to visualise shifting

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input 1  | output bit 1 |
| 1 | input 2  | output bit 2 |
| 2 | input 3  | output bit 3 |
| 3 | input 4  | output bit 4 |
| 4 | shift type  | none |
| 5 | select 1  | none |
| 6 | select 2  | none |
| 7 | hardcode 0  | none |

\pagebreak
# Pseudo-random number generator



* Author Thomas B√∂hm <thomas.bohm@gmail.com>
* Description Pseudo-random number generator using a 16-bit Fibonacci linear-feedback shift register
* [GitHub project](https://github.com/tcptomato/tinytapeout)
* [Wokwi project](https://wokwi.com/projects/341178154799333971)
* [Extra docs](https://github.com/tcptomato/tinytapeout//blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

16 flip flops are connected in a chain, and the output of some is XORed together and fed back into the first flip flop. The outputs that are XORed together are chosen in such a way as to give the longest possible cycle (2^16-1). All bits being zero is a special case and is treated separately (all negative outputs of the flip flops are ANDed together to generate a 1 as feedback).
On each clock pulse (pin 1) one new bit is generated. Setting load_en (pin 3) to HIGH allows the loading of a user defined value through the data_in pin (pin2). On each clock pulse one bit is read into the flip flop chain. When load_en (pin 3) is set to LOW the computed feedback bit is fed back into the flip flops.
The outputs of the last 8 flip flops are connected to the output pins. For each clock pulse a random bit is generated and the other 7 are shifted. 

## How to test

Set the switch for pin 1 so that the push button generates the clock. Press on it and see the output change on the hex display.
Using pin 2 and 3 a custom value can be loaded into the flip flops. 

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | random bit 0 |
| 1 | data_in  | random bit 1 |
| 2 | load_en  | random bit 2 |
| 3 | none  | random bit 3 |
| 4 | none  | random bit 4 |
| 5 | none  | random bit 5 |
| 6 | none  | random bit 6 |
| 7 | none  | random bit 7 |

\pagebreak
# BCD to 7 Segment Decoder



* Author Pramit Pal
* Description Setting the DIP switches as a BCD Value displays the BCD Value 0-9 in the 7 segment display
* [GitHub project](https://github.com/pramitpal/tinytapeout_pramit)
* [Wokwi project](https://wokwi.com/projects/341162950004834900)
* [Extra docs](https://github.com/pramitpal/tinytapeout_pramit/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

Display BCD Value given by user with the 7 segment display

## How to test

Turning on the last 4 input switches to display BCD Value

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input 4  | segment a |
| 1 | none  | segment b |
| 2 | none  | segment c |
| 3 | none  | segment d |
| 4 | input 3  | segment e |
| 5 | input 2  | segment f |
| 6 | input 1  | segment g |
| 7 | input 0  | dot |

\pagebreak
# Fibonacci & Gold Code



* Author Daniel Estevez
* Description This project includes two independent designs: a design that calculates terms of the Fibonacci sequence and displays them in hex one character at a time on a 7-segment display, and a Gold code generator that generates the codes used by CCSDS X-band PN Delta-DOR.
* [GitHub project](https://github.com/daniestevez/tinytapeout-verilog)
* [Wokwi project](https://wokwi.com/projects/341164910646919762)
* [Extra docs]()
* Clock 0 Hz
* External hardware No external hardware is needed

## How it works

The Fibonacci calculator uses 56-bit integers, so the terms of the Fibonacci sequence are displayed using 7 hex characters. Since the TinyTapeout PCB only has one 7-segment display, the terms of the Fibonacci sequence are displayed one hex character at a time, in LSB order. The dot of the 7-segment display lights up whenever the LSB is being displayed. On each clock cycle, 4-bits of the next Fibonacci term are calculated using a 4-bit adder, and 4-bits of the current term are displayed in the 7-segment display. The 7-segment display is ANDed with the project clock, so that the digits flash on the display. The Gold code generator computes a CCSDS X-band PN Delta-DOR Gold code one bit at a time using LFSRs. The output bit is shown on the 7-segment display dot. 6-bits of the second LFSR can be loaded in parallel using 6 project inputs in order to be able to generate different sequences. One of the project inputs is used to select whether the 7-segment display dot is driven by the Fibonacci calculator or by the Gold code generator.

## How to test

The project can be tested by manually driving the clock using a push button or switch. Just by de-asserting the reset and driving the clock, the digits of the Fibonacci sequence terms should appear on the 7-segment display. The output select input needs to be set to Gold code (high level) in order to test the gold code generator. The load enable input (active-low), as well as the 6 inputs corresponding to the load for the B register can be used to select the sequence to generate. The load value can be set in the 6 load inputs, and then the load enable should be pulsed to perform the load. This can be done with the clock running or stopped, as the load enable is asynchronous. After the load enable is de-asserted, for each clock cycle a new bit of the Gold code sequence should appear in the 7-segment display dot.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | {'segment a': 'Fibonacci hex digit'} |
| 1 | output select (high selects Gold code; low selects Fibonacci LSB marker) & Gold code load value bit 0  | {'segment b': 'Fibonacci hex digit'} |
| 2 | Fibonacci reset (active-low; asynchronous) & Gold code load value bit 1  | {'segment c': 'Fibonacci hex digit'} |
| 3 | Gold code load enable (active-low; asynchronous)  | {'segment d': 'Fibonacci hex digit'} |
| 4 | Gold code load value bit 2  | {'segment e': 'Fibonacci hex digit'} |
| 5 | Gold code load value bit 3  | {'segment f': 'Fibonacci hex digit'} |
| 6 | Gold code load value bit 4  | {'segment g': 'Fibonacci hex digit'} |
| 7 | Gold code load value bit 5  | {'none': 'Gold code output / Fibonacci LSB digit marker'} |

\pagebreak
# GPS C/A PRN Generator



* Author Adam Greig
* Description Generate any of the GPS C/A PRN sequences from PRN0 to PRN31
* [GitHub project](https://github.com/adamgreig/tinytapeout-prn)
* [Wokwi project](https://wokwi.com/projects/341342096033055316)
* [Extra docs](https://github.com/adamgreig/tinytapeout-prn/)
* Clock 1000 Hz
* External hardware None

## How it works

Instantiates the GPS G1 and G2 LFSRs to generate a pseudo-random sequence, then selects the G2 output taps based on the input signals to output the chosen sequence.

## How to test

Apply clock to the in[0], pulse reset on in[1], choose a PRN between 0 and 31 using in[2:7], then the G1 sequence is emitted on out[0], the G2 sequence on out[1], and the selected PRN on out[2]. The first 20 bits of PRN2 are 11100100001110000011.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | G1 subsequence |
| 1 | reset  | G2 subsequence |
| 2 | prn[0]  | Selected PRN |
| 3 | prn[1]  | None |
| 4 | prn[2]  | None |
| 5 | prn[3]  | None |
| 6 | prn[4]  | None |
| 7 | none  | None |

\pagebreak
# PDP-0: 4-bit CPU in the style of PDP-1/TX-0



* Author Tommy Thorn
* Description The tiny 4-bit CPU packs a 3b program counter, an accumulator, and 8 6b words.
* [GitHub project](https://github.com/tommythorn/tinytapeout-4-bit-cpu)
* [Wokwi project](https://wokwi.com/projects/341193419111006803)
* [Extra docs]()
* Clock 0 Hz
* External hardware Besides interactining with the IOs, nothing is needed

## How it works

The two top bits in each word form the opcode (load, store, add, branch-if-zero) while the remaining four are the immediate field that the opcode uses.  Load and store only access the immediate field of the word.  The IO implements a simple command protocol to reset, load data, load code, and run.  The output are used for the PC and the Accumulator.  The test bench shows how to load a fibonacci computing program.

## How to test

Use the command protocol to load programs and run them (see test bench)

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | acc[0] |
| 1 | cmd[0]  | acc[1] |
| 2 | cmd[1]  | acc[2] |
| 3 | not used  | acc[3] |
| 4 | cmdarg[0]  | pc[0] |
| 5 | cmdarg[1]  | pc[1] |
| 6 | cmdarg[2]  | pc[2] |
| 7 | cmdarg[3]  | Not used, wired to 0 |

\pagebreak
# Game of Life - Cell Neighbor Count



* Author Uri Shaked (Wokwi)
* Description Logic to decide about the fate of a cell in the game of life: die, stay alive, or spring to life
* [GitHub project](https://github.com/wokwi/tt-game-of-life-cell-popcnt)
* [Wokwi project](https://wokwi.com/projects/341266732010177108)
* [Extra docs](https://github.com/wokwi/tt-game-of-life-cell-popcnt/blob/main/README.md)
* Clock 0 Hz
* External hardware 

## How it works

The 8 inputs represent the current state of the neighboring cells (0 = dead, 1 = alive). The fate of the cell is in bits 2 and 3 of the output. The cell will be alive if either bit 2 is on and it was alive in the previous generation, or if bit 3 is on. Otherwise, it'll die.

## How to test

Connect 8 DIP switches to the 8 input pins, and LEDs to bits 2 and 3 of the output. Observe the value of the output bits: bit 2 should be on when either two or three of the DIP switches are on, and bit 3 should be on when exactly three DIP switches are on.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | in0  | none |
| 1 | in1  | none |
| 2 | in2  | 2 or 3 inputs are high |
| 3 | in3  | exactly 3 inputs are high |
| 4 | in4  | none |
| 5 | in5  | none |
| 6 | in6  | none |
| 7 | in7  | none |

\pagebreak
# Traffic Light FSM



* Author Christian Fibich
* Description FSM controlling two (red-yellow-green) traffic lights
* [GitHub project](https://github.com/cfib/trafficlight-fsm)
* [Wokwi project](https://wokwi.com/projects/341410909669818963)
* [Extra docs]()
* Clock 2 Hz
* External hardware 2 red LEDs, 2 yellow LEDs, 2 green LEDs and current limiting resistors

## How it works

State machine that implements a typical Austrian traffic light: Red -> Red+Yellow -> Green -> Green Blinking -> Yellow -> Red. Generated using a hacked-together Verilog->Wokwi flow :D.

## How to test

Starts in 'error' mode (yellow blinking). Switch SW1 (reset) to 1 and back to 0 to start operation. 'error' mode can be reached by toggling SW2.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | red 1 |
| 1 | reset  | yellow 1 |
| 2 | enter_error_mode  | green 1 |
| 3 | none  | red 2 |
| 4 | none  | yellow 2 |
| 5 | none  | green 2 |
| 6 | none  | none |
| 7 | none  | none |

\pagebreak
# 7 Segment Figure Eight



* Author Christian Lyder Jacobsen
* Description 
* [GitHub project](https://github.com/clj/tinytapeout-verilog-7seg-figure-eight)
* [Wokwi project](https://wokwi.com/projects/341063825089364563)
* [Extra docs](https://github.com/clj/tinytapeout-verilog-7seg-figure-eight/blob/main/README.md)
* Clock 0 Hz
* External hardware 

## How it works



## How to test



## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | reset  | segment b |
| 2 | speed lsb  | segment c |
| 3 | speed  | segment d |
| 4 | speed msb  | segment e |
| 5 | tail  | segment f |
| 6 | direction  | segment g |
| 7 | led invert  | none |

\pagebreak
# Logic-2G57-2G58



* Author Sirawit Lappisatepun
* Description Replication of TI's Little Logic 1G57 and 1G58 configurable logic gates.
* [GitHub project](https://github.com/Sirawit7205/tinytapeout-2G57-2G58)
* [Wokwi project](https://wokwi.com/projects/341431339142087251)
* [Extra docs]()
* Clock 0 Hz
* External hardware 

## How it works

This design replicates the circuit inside a TI configurable logic gates 74xx1G57 (and by including an inverted output, it will work as a 74xx1G58 as well). Since there are still I/O pins left, I included two of these configurables, and also one 74xx1G79 D Flip-Flop (again, an inverted output means this will also work as a 74xx1G80).

## How to test

You could refer to TI's 1G79/1G80/1G57/1G58 datasheet to test the device according to the pinout listed below.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | dff_clock  | dff_out |
| 1 | dff_data  | dff_out_bar |
| 2 | gate1_in0  | gate1_out |
| 3 | gate1_in1  | gate1_out_bar |
| 4 | gate1_in2  | gate2_out |
| 5 | gate2_in0  | gate2_out_bar |
| 6 | gate2_in1  | none |
| 7 | gate2_in2  | none |

\pagebreak
# Logic-2G97-2G98



* Author Sirawit Lappisatepun
* Description Replication of TI's Little Logic 1G97 and 1G98 configurable logic gates.
* [GitHub project](https://github.com/Sirawit7205/tinytapeout-2G97-2G98)
* [Wokwi project](https://wokwi.com/projects/341432030163108435)
* [Extra docs]()
* Clock 0 Hz
* External hardware 

## How it works

This design replicates the circuit inside a TI configurable logic gates 74xx1G97 (and by including an inverted output, it will work as a 74xx1G98 as well). Since there are still I/O pins left, I included two of these configurables, and also one 74xx1G79 D Flip-Flop (again, an inverted output means this will also work as a 74xx1G80).

## How to test

You could refer to TI's 1G79/1G80/1G97/1G98 datasheet to test the device according to the pinout listed below.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | dff_clock  | dff_out |
| 1 | dff_data  | dff_out_bar |
| 2 | gate1_in0  | gate1_out |
| 3 | gate1_in1  | gate1_out_bar |
| 4 | gate1_in2  | gate2_out |
| 5 | gate2_in0  | gate2_out_bar |
| 6 | gate2_in1  | none |
| 7 | gate2_in2  | none |

\pagebreak
# Digital padlock



* Author Jean THOMAS
* Description A 4-digit electronic padlock
* [GitHub project](https://github.com/jeanthom/tinytapout-lock)
* [Wokwi project](https://wokwi.com/projects/341438392303616596)
* [Extra docs](README.md)
* Clock 100 Hz
* External hardware 

## How it works

Each buttons press is detected by a rising edge detector, and each button press is decoded into a binary code. That binary code is stored in a shift-register which is continuously checked against a reference value ('the padlock code').

## How to test

Connect a clock generator to the clock input, connect all four buttons with a debounce circuit - the buttons should act as active high.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | none |
| 1 | Button A  | none |
| 2 | Button B  | none |
| 3 | Button C  | none |
| 4 | Button D  | none |
| 5 | none  | none |
| 6 | none  | Button press detected |
| 7 | none  | Code valid |

\pagebreak
# TinyIO



* Author Aidan Medcalf
* Description Tiny I/O expander with SPI interface
* [GitHub project](https://github.com/AidanMedcalf/tinytapeout-tinyio)
* [Wokwi project](https://wokwi.com/projects/341432284947153491)
* [Extra docs](https://github.com/AidanMedcalf/tinytapeout-tinyio/blob/main/README.md)
* Clock 0 Hz
* External hardware SPI driver

## How it works

TinyIO takes 7 bits in as digital outputs, and sends 3 bits out from its digital inputs.

## How to test

7-bit SPI transaction. Supply nCE, SIN and SCK.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | out0 |
| 1 | reset  | out1 |
| 2 | serial clock  | out2 |
| 3 | chip enable  | out3 |
| 4 | serial in  | out4 |
| 5 | in0  | out5 |
| 6 | in1  | out6 |
| 7 | in2  | serial out |

\pagebreak
# 4-bit-asychronous multiplier



* Author Hirosh Dabui
* Description Asychronous 4-bit multiplier that return 8-bit
* [GitHub project](https://github.com/splinedrive/tinytapeout-verilog-4x4-multiplier)
* [Wokwi project](https://wokwi.com/projects/341493393195532884)
* [Extra docs](https://github.com/splinedrive/tinytapeout-verilog-4x4-multiplier/blob/main/README.md)
* Clock 0 Hz
* External hardware 2x4-switches and 8 leds

## How it works

2x4bit operands and 8bit result

## How to test

Feed the 4-bit-operands and get the multiplication

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | input a0  | output c[0] |
| 1 | input a1  | output c[1] |
| 2 | input a2  | output c[2] |
| 3 | input a0  | output c[3] |
| 4 | input b1  | output c[4] |
| 5 | input b2  | output c[5] |
| 6 | input b3  | output c[6] |
| 7 | input b3  | output c[7] |

\pagebreak
# Figure 8 pattern generator



* Author todd1251
* Description Generates a figure 8 pattern on the 7-segment display
* [GitHub project](https://github.com/todd1251/tinytapeout-figure8)
* [Wokwi project](https://wokwi.com/projects/341243232292700755)
* [Extra docs]()
* Clock 1 Hz
* External hardware 

## How it works



## How to test



## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | reset  | segment b |
| 2 | none  | segment c |
| 3 | none  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | none  | segment g |
| 7 | none  | none |

\pagebreak
# Picture Printer



* Author Miron Zadora
* Description Outputs the Edinburgh Hacklab logo pixel by pixel
* [GitHub project](https://github.com/ElectricPotato/tinytapeout-picture-printer-b)
* [Wokwi project](https://wokwi.com/projects/341542971476279892)
* [Extra docs](https://github.com/ElectricPotato/tinytapeout-picture-printer-b/blob/main/README.md)
* Clock 1000 Hz
* External hardware Something to decode and display the image. E.g. An arduino connected to the chip Clock and Pixel Output pins could be used to display the 1s and 0s coming from the chip as '@' and '.' characters in a serial console, putting a newline every 41 characters (41 is the width of the image)

## How it works

It outputs the image pixel by pixel, line by line, left to right, top to bottom. 1 pixel per clock cycle. Image is 41 by 41 pixels. 1 = black pixel, 0 = white pixel.

## How to test

Supply a clock to 1st input and hold 2nd input high for one clock cycle to reset. Everything in the design happens on the rising edge of the clock. Connect external hardware described below.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | Clock  | Pixel output |
| 1 | Synchronous reset  | none |
| 2 | none  | none |
| 3 | none  | none |
| 4 | none  | none |
| 5 | none  | none |
| 6 | none  | none |
| 7 | none  | none |

\pagebreak
# 4-bit ALU with 7 segment display decoder hexadecimal output



* Author Michael Gargano
* Description a 4-bit ALU with 8 different possible operations on an internal accumulator whose current 4-bit state is displayed in hexadecimal on the segmented display
* [GitHub project](https://github.com/mgargano/tinytapeout_alu_with_4bit_7segmetdisplay_decoder)
* [Wokwi project](https://wokwi.com/projects/341538994733974098)
* [Extra docs]()
* Clock 0 Hz
* External hardware None

## How it works

3-bit decoder picks operation pass-through, bit-wise (NOT, AND, OR, XOR), two's complement, add, or subtract circuit based on selection and stores the result in a 4-bit accumulator, after the pressing the step button, the 4-bit to 7-segment display decoder circuits then take that value and display it hexadecimal

## How to test

select one of the 8 alu operations [switches 4-2] (pass-through 0, bit-wise NOT 1, bit-wise AND 2, bit-wise OR 3, bit-wise XOR 4, add 5, two's compliment 6, subtract 7) then input a 4-bit number [switches 8-5], press step button to perform the selected computation and the display will indicate current 4-bit accumulator value in hex, dot indicates if a carry is output during addition or subtraction

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock (or single step with step button)  | segment a of hex output |
| 1 | alu operation selection bit 2  | segment b of hex output |
| 2 | alu operation selection bit 1  | segment c of hex output |
| 3 | alu operation selection bit 0  | segment d of hex output |
| 4 | input bit 3  | segment e of hex output |
| 5 | input bit 2  | segment f of hex output |
| 6 | input bit 1  | segment g of hex output |
| 7 | input bit 0  | dot (indicates carry) |

\pagebreak
# An optionally cumulative adder



* Author Michael Christen
* Description Increment with clock and add previous result or current A + B
* [GitHub project](https://github.com/michael-christen/wokwi-verilog-asic-experiment)
* [Wokwi project](https://wokwi.com/projects/341569483755749970)
* [Extra docs](https://wokwi.com/projects/341569483755749970)
* Clock 1 Hz
* External hardware LEDs and switches would be handy

## How it works

A, B are 3 bits, there's a clock and a selctor to use A or (A + B)'

## How to test

Toggle clock to run increment, swap between acumulating or just adding with switch 2; 3-5 are A, 6-8 are B

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | reset  | segment b |
| 2 | none  | segment c |
| 3 | none  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | none  | segment g |
| 7 | none  | none |

\pagebreak
# tinytapeout-HELLo-3orLd-7seg



* Author Rakesh Peter
* Description HELLo-3orLd Runner on 7 segment Display
* [GitHub project](https://github.com/r4d10n/tinytapeout-HELLo-3orLd-7seg)
* [Wokwi project](https://wokwi.com/projects/341609034095264340)
* [Extra docs](https://github.com/r4d10n/tinytapeout-HELLo-3orLd-7seg/blob/main/README.md)
* Clock 1 Hz
* External hardware none

## How it works

BCD Counter with 7 seg Decoder

## How to test

All toggle switches in zero position and clock switch on for auto runner. Individual BCD bits can be toggled using corresponding inputs with clock switch off.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | reset  | segment b |
| 2 | none  | segment c |
| 3 | dp toggle  | segment d |
| 4 | BCD bit 3  | segment e |
| 5 | BCD bit 2  | segment f |
| 6 | BCD bit 1  | segment g |
| 7 | BCD bit 0  | segment dp |

\pagebreak
# Wolf sheep cabbage river crossing puzzle ASIC design (üê∫üêêü•¨üö£)



* Author maehw
* Description Play the wolf, goat and cabbage puzzle interactively.
* [GitHub project](https://github.com/maehw/wokwi-verilog-gds-wolf-goat-cabbage)
* [Wokwi project](https://wokwi.com/projects/341614346808328788)
* [Extra docs](https://github.com/maehw/wokwi-verilog-gds-wolf-goat-cabbage/blob/main/README.md)
* Clock 0 Hz
* External hardware Input switches and 7-segment display

## How it works

Truth table with the game logic (hidden easter egg). The inputs are the positions of the farmer, wolf, goat and cabbage. The 7-segment display shows the status of the game (won or lost).

## How to test

Slide the input switches, think, have a look at the 7-segment display.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | not connected because it is typically used for clocked designs and may be used in the future of this design  | output signal ~E, i.e. the top and bottom segments light up, when the game is over ‚ùå‚ùå‚ùå due to an unattended situation on any river bank side |
| 1 | input signal F for the position of the farmer (üßë‚Äçüåæ/üö£)  | output signal ~R i.e. the top-right and bottom-right segments light up, to indicate an unattended situation on the right river bank (game over ‚ùå) |
| 2 | input signal W for the position of the wolf (üê∫)  | output signal ~R i.e. the top-right and bottom-right segments light up, to indicate an unattended situation on the right river bank (game over ‚ùå) |
| 3 | input signal G for the position of the goat (üêê)  | output signal ~E, i.e. the top and bottom segments light up, when the game is over ‚ùå‚ùå‚ùå due to an unattended situation on any river bank side |
| 4 | input signal C for the position of the cabbage (ü•¨)  | output signal ~L i.e. the top-left and bottom-left segments light up, to indicate an unattended situation on the left river bank (game over ‚ùå) |
| 5 | here be dragons or an easter egg  | output signal ~L i.e. the top-left and bottom-left segments light up, to indicate an unattended situation on the left river bank (game over ‚ùå) |
| 6 | unused  | here be dragons or an easter egg |
| 7 | unused  | output signal A to light up the "dot LED" of the 7 segment display as an indicator that all objects have reached the right bank of the river and the game is won! üéâüéâüéâ |

\pagebreak
# Figure of 8 orbit animation



* Author Rajarshi Roy
* Description Stepping using button will show a figure of 8 orbit animation on 7 segment display
* [GitHub project](https://github.com/rajarshiroy/tinytapout0_rajarshi)
* [Wokwi project](https://wokwi.com/projects/341614536664547922)
* [Extra docs](https://github.com/rajarshiroy/tinytapout0_rajarshi/blob/main/README.md)
* Clock 0 Hz
* External hardware None

## How it works

Signal goes through ring shift register, each flop in shift register is connected to a segment in the display.

## How to test

In button stepping mode, turn on switch 8 and press multiple times to fill figure of 8 with signal from switch 7, then toggle switch 7, step once, turn off switch 8, then keep stepping to see the orbit animation.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | none  | segment b |
| 2 | none  | segment c |
| 3 | none  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | value of signal to enter into ring shift register when switch 8 is enabled  | segment g |
| 7 | insert new signal from switch 7 into ring shift register  | dot shows when switch 8 is enabled |

\pagebreak
# Low-speed UART transmitter with limited character set loading



* Author maehw
* Description 300(?) baud UART transmitter (8N1) with limited character set (0x40..0x5F; includes all capital letters in the ASCII table) loading.
* [GitHub project](https://github.com/maehw/wokwi-verilog-gds-lowspeed-tiny-uart)
* [Wokwi project](https://wokwi.com/projects/341631511790879314)
* [Extra docs](https://github.com/maehw/wokwi-verilog-gds-lowspeed-tiny-uart/blob/main/README.md)
* Clock 300 Hz
* External hardware UART receiver or oscilloscope or logic analyzer (optional)

## How it works

The heart of the design is a 13 bit shift register (built from D flip-flops). When a word has been transmitted, it will be transmitted again and again until a new word is loaded into the shift register or the output is disabled (the word will keep on cycling internally).

## How to test

Load a character into the design and attach a UART receiver (or oscilloscope or logic analyzer) on the output side.

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | 300 Hz input clock signal (or different value supported by the whole  | UART (serial output pin, direct throughput) |
| 1 | bit b0 (the least significant bit) of the loaded and transmitted character  | UART (serial output pin, gated by enable signal) |
| 2 | bit b1 of the loaded and transmitted character  | UART (serial output pin, reverse polarity, direct throughput) |
| 3 | bit b2 of the loaded and transmitted character  | UART (serial output pin, reverse polarity, gated by enable signal) |
| 4 | bit b3 of the loaded and transmitted character  | UART (MSBit, direct throughput); typically set to 1 or can be used to sniffing the word cycling through the shift register) |
| 5 | bit b4 of the loaded and transmitted character  | UART (MSBit, reverse polarity, direct throughput); same usage as above |
| 6 | load word into shift register from parallel input (IN1..IN5) (1) or cycle the existing word with start/stop bits around it (0)  | UART (MSBit, gated by enable signal); typically set to 1 or can be used to sniffing the word cycling through the shift register) |
| 7 | {'output enable (for gated output signals)': '1 output is enabled, 0 output is disabled (permanently set to HIGH/1)'}  | UART (MSBit, reverse polarity, gated by enable signal); same usage as above |

\pagebreak
# LAB11



* Author Thomas Zachariah
* Description Cycles through the characters of LAB11
* [GitHub project](https://github.com/tzachari/tinytapeout-lab11)
* [Wokwi project](https://wokwi.com/projects/341631644820570706)
* [Extra docs](https://github.com/tzachari/tinytapeout-lab11)
* Clock 2 Hz
* External hardware None

## How it works

Gates & flip-flops connected to the 7-segment display change the state of corresponding LED segments to form the next character, each cycle

## How to test

Set to desired clock speed ‚Äì characters are most readable at the lowest speed

## IO

| # | Input        | Output       |
|---|--------------|--------------|
| 0 | clock  | segment a |
| 1 | reset  | segment b |
| 2 | none  | segment c |
| 3 | none  | segment d |
| 4 | none  | segment e |
| 5 | none  | segment f |
| 6 | none  | segment g |
| 7 | none  | none |

\pagebreak
